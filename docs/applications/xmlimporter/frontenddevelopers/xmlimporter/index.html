<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>XML Importer overview (a.k.a. TCP 2.0)</title><link href="../../../../style/documentation.css" rel="stylesheet" type="text/css" /><meta content="DocBook XSL Stylesheets V1.72.0" name="generator" /><link xmlns="" type="image/x-icon" href="../../../../style/favicon.ico" rel="icon" /><link xmlns="" type="image/x-icon" href="../../../../style/favicon.ico" rel="shortcut icon" /><meta xmlns="" content="text/html; charset=utf-8" http-equiv="content-type" /></head><body><div xmlns="" class="navigation"><img alt="mmbase logo" src="../../../../style/logo.png" /><h2>XML Importer overview (a.k.a. TCP 2.0)</h2><p><a href="index.html#N10021">Introduction</a></p><p><a href="index.html#N1002A">Import scenario's supported by TCP semantics</a></p><p><a href="index.html#N10055">TCP 2.0: a new sophisticated import scenario: Find and Merge</a></p><p><a href="index.html#N10074">Find and Merge scenario details</a></p><p><a href="index.html#N10097">Extensions to the TCP-semantics: TCP 2.0</a></p><p><a href="index.html#N100F8">TransactionHandler enhancements (performance and usability)</a></p><p><a href="index.html#N10113">TCP 2.0 Syntax</a></p><p><a href="index.html#N1015D">TCP 2.0 dtd</a></p><hr /><p><a href="http://www.mmbase.org">MMBase</a></p><p><a href="../../../../index.html">home</a></p></div><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="N10001" />XML Importer overview (a.k.a. TCP 2.0)</h1></div><div><div class="authorgroup"><strong class="authorgroup">Author: </strong><span class="author"><span class="firstname">Rob</span> <span class="surname">van Maris</span></span><br /><strong class="authorgroup">Date: </strong>2001-12-24</div></div><div><div class="legalnotice"><a id="N10018" /><p>This software is OSI Certified Open Source Software. OSI Certified is a certification mark of the Open Source Initiative.</p><p>The license (Mozilla version 1.0) can be read at the MMBase site. See <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mmbase.org/license" target="_top">http://www.mmbase.org/license</a></p></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="index.html#N10021">1. Introduction</a></span></dt><dt><span class="section"><a href="index.html#N1002A">2. Import scenario's supported by TCP semantics</a></span></dt><dt><span class="section"><a href="index.html#N10055">3. TCP 2.0: a new sophisticated import scenario: Find and Merge</a></span></dt><dt><span class="section"><a href="index.html#N10074">4. Find and Merge scenario details</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#N10079">4.1. Object similarity</a></span></dt><dt><span class="section"><a href="index.html#N10082">4.2. Merging objects</a></span></dt><dt><span class="section"><a href="index.html#N10087">4.3. Unreferenced objects</a></span></dt><dt><span class="section"><a href="index.html#N1008C">4.4. Feedback</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#N10097">5. Extensions to the TCP-semantics: TCP 2.0</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#N1009C">5.1. new object operator: mergeObjects (objectType)</a></span></dt><dt><span class="section"><a href="index.html#N100AA">5.2. objectFinder</a></span></dt><dt><span class="section"><a href="index.html#N100B1">5.3. objectMerger</a></span></dt><dt><span class="section"><a href="index.html#N100B8">5.4. new parameter for createObject: disposeWhenNotReferenced</a></span></dt><dt><span class="section"><a href="index.html#N100BD">5.5. new parameter for transactions: reportFile</a></span></dt><dt><span class="section"><a href="index.html#N100C2">5.6. SimilarObjectFinder interface</a></span></dt><dt><span class="section"><a href="index.html#N100D4">5.7. ObjectMerger interface</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#N100F8">6. TransactionHandler enhancements (performance and usability)</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#N100FD">6.1. Performance</a></span></dt><dt><span class="section"><a href="index.html#N10102">6.2. Usability</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#N10113">7. TCP 2.0 Syntax</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#N1011C">7.1. Transactions context</a></span></dt><dt><span class="section"><a href="index.html#N10128">7.2. Transaction contexts</a></span></dt><dt><span class="section"><a href="index.html#N10137">7.3. Object contexts</a></span></dt><dt><span class="section"><a href="index.html#N1014B">7.4. Object Merge contexts</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#N1015D">8. TCP 2.0 dtd</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N10021" />1. Introduction</h2></div></div></div><p>The goal of the XML importer is to extend MMBase with powerful new XML import facilities, facilitating bulk import of data from different sources (e.g. third parties). </p><p>This document gives an overview of the XML Importer that is brought to the open source distribution of MMBase. The XML Importer is largely based on an implementation that is build and tested for the VPRO. </p><p>Before the XML Importer project, one way to bulk import data in an efficient way, was by means of XML-defined transactions, using the vocabulary defined by the Temporary Cloud Project (TCP). While these semantics are sufficient to populate empty MMBase tables with new objects, they are very limited in other situations. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N1002A" />2. Import scenario's supported by TCP semantics</h2></div></div></div><p>There are two TCP scenarios supported by MMBase through TCP semantics. The simplest scenario for bulk data input is adding new object graphs:</p><div class="itemizedlist"><ul type="disc"><li>Create a transaction context.</li><li>Create new objects within the transaction context.</li><li>Create new relations between these objects.</li><li>Commit the transaction.</li></ul></div><p>As a result the new objects and relations are added to MMBase. If similar objects were already present in MMBase, this would result in duplicates.</p><p>To demonstrate how this translates to TCP-semantics, the following example adds two new objects (type "movie" and "person") with one relation ("director"): </p><pre class="programlisting">
&lt;transactions&gt;
	&lt;create&gt;
		&lt;createobject id ="m1" type="movies"&gt;
			&lt;setfield name="title"&gt;psycho&lt;/setfield&gt;
			&lt;setfield name="year"&gt;1960&lt;/setfield&gt;
		&lt;/createobject&gt;

		&lt;createObject id="p1" type="persons"&gt;
			&lt;setField name="firstname"&gt;Alfred&lt;/setField&gt;
			&lt;setField name="lastname"&gt;Hitchcock&lt;/setField&gt;
		&lt;/createobject&gt;

		&lt;createRelation type="director" source="m1" destination="p1"/&gt;
	&lt;/create&gt;
&lt;/transactions&gt;
		</pre><p>The second and slightly more advanced TCP scenario adds new object graphs, involving existing MMBase objects as well:</p><div class="itemizedlist"><ul type="disc"><li>Create a transaction context.</li><li>Create new objects within the transaction context.</li><li>Access existing MMBase objects, this creates copies within the context.</li><li>Create new relations between the objects.</li><li>Commit the transaction.</li></ul></div><p>This results in both new objects and new relations, involving both new and existing objects. </p><p>Disadvantage of the latter scenario is, the MMBase objects involved have to be explicitly identified by their MMBase-id. Because of this, we cannot define such a transaction without prior inspection of existing MMBase objects.</p><p>This example demonstrates how an existing MMBase object can be accessed within a transaction, to set its fields to new values:</p><pre class="programlisting">
&lt;accessObject id="p1" mmbaseId="12345"&gt;
	&lt;setField name="firstname"&gt;Alfred&lt;/setField&gt;
	&lt;setField name="lastname"&gt;Hitchcock&lt;/setField&gt;
&lt;/accessObject&gt;
		</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N10055" />3. TCP 2.0: a new sophisticated import scenario: Find and Merge</h2></div></div></div><p>XML Importer introduces a more sophisticated scenario that:</p><div class="itemizedlist"><ul type="disc"><li>presents a number of objects and relations that should be present in MMBase without previous knowledge of which actual objects and relations are already present in MMBase.</li><li>uses object (sub) graphs instead of the mmbaseId.</li></ul></div><p>Formally speaking: we present MMBase with the object (sub)graphs that we want to be in MMBase. This approach focuses on the desired result, instead of detailing the steps to be taken. It shifts the burden of detailing all the steps to the side of MMBase. </p><p>In order to see how to accomplish this, let's look at an example. We want to add the same objects ("persons" and "movies") and relation ("director") as in the previous examples, but following the proposed scenario, that avoids duplicates by taking into account the objects already present in MMBase. </p><div class="orderedlist"><ol type="1"><li>Create transaction context.</li><li>Create the objects within the transaction context (further called "input objects").</li><li>Create the relation between these objects.</li><li>Look for a "movies" object in MMBase that is similar to the input movies object. If such an object is found, access it within the context (further called "access object"), and have it replace the original input object. The MMBase object then becomes the new destination of the relation.</li><li>Look for a "persons" object in MMBase that is similar to the input person. If such an object is found, access it within the context, end have it replace the original input object. The MMBase object then becomes the new source of the relation.</li><li>Look for a similar relation in MMBase. If such an object is found, delete the original input relation.</li><li>Commit the transaction.</li></ol></div><p>This transaction will result in both objects and the relation to be present in MMBase, regardless of what was present before the transaction, and without duplicates being created. This is the behavior we are looking for.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N10074" />4. Find and Merge scenario details</h2></div></div></div><p>Note that these steps as presented in the previous paragraph are actually very straight forward, and can easily be formalized to cover the general case of many objects and relations. Also note that the results depend on a notion of object similarity, so let's look into what we really mean by that (having avoided using the word "equality").</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N10079" />4.1. Object similarity</h3></div></div></div><p>The notion of two MMBase objects, candidate or present, being considered "similar" is not as straightforward as may seem.</p><p>A definition might be to consider them similar if all their fields are equal. But in practice, this definition might be not restrictive enough in some cases, while being too restrictive in others. For instance, we can think of situations where it is only acceptable to consider objects equal if the objects they have relationships with, are also equal (i.e. movies should not only have the same title, but also the same director).</p><p>On the other hand, data-entry by hand into textfields may introduce all kind of minor errors, resulting in objects having different fields, while meant to represent the same object. In this case object similarity may translate into "similar enough" - using fuzzy-logic comparison. Clearly, if we want to bulk import data, while at the same time relying heavily on a concept of object similarity, we must be able to specify our own criteria of how to find a similar object. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N10082" />4.2. Merging objects</h3></div></div></div><p>In our example we replace our input object by the object already present in MMBase. This is not always desirable. For example the input object may contain a person's birthdate, while this field is empty in the MMBase object. In that case we might want the birthdate value to be copied to the existing MMBase object as well. Generalizing this approach we could say that we create a new object based on two objects that are both replaced by it - we will refer to this as "merging" objects. For objects to be merged, we have to specify how the fields and relations of the resulting object are set, based on the original objects/relations. Note that we may choose to drop relations that involved one of the original objects. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N10087" />4.3. Unreferenced objects</h3></div></div></div><p>Since relations can be dropped when objects are merged, input objects may lose all their relations with other objects. Some types of objects are only of interest because the relations they have with other objects. We have to be able to specify that we don't want these object added to MMBase when they have become "unreferenced", e.g. not related to other objects.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N1008C" />4.4. Feedback</h3></div></div></div><p>Processing of a transaction may fail because for an input object more than one similar object is found or an error occurs XXX the import is stopped XXX but this will not stop the whole import. The current transaction is canceled. The Importer continues with the next transaction. All transactions without duplicates or errors are committed to MMBase.</p><p>If for an input object more than one similar object is found the following happens. The complete transaction is appended to a report file.
In the next stage duplicates_transactions.XML is processed. The user has to be consulted to decide which merge result is preferred.</p><p>Example. If there was an input object A and two similar objects were found (B and C). The following is presented to the user user on screen (probably a jsp page): the original input object (A) and for every similar object the merge result. Thus (A+B) and (A+C). The user has to select which merge result is preferred. Processing of this corrected transaction can continue in a next processing cycle.</p><p>All other kind of errors, e.g. syntax error (XML not according to dtd) or object field not found or object not found. For all these errors the transaction processing is canceled an entry is written to a report file and the full transaction is written to a file (e.g. error_transactions.XML). XXX the import is stopped XXX The user can consult the report-file afterward to review the transactions that went wrong. The report-file will contain all information necessary to correct the problems and give these transactions a second try. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N10097" />5. Extensions to the TCP-semantics: TCP 2.0</h2></div></div></div><p>To implement the Find and Merge scenario extension of the TCP-semantics is necessary. These extended semantics allow us to instruct the Transaction Handler to carry out the tasks.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N1009C" />5.1. new object operator: mergeObjects (objectType)</h3></div></div></div><p>For all input objects within the transaction context of the type specified by objectType, perform the following actions:</p><div class="orderedlist"><ol type="1"><li>Look for similar objects in MMBase and elsewhere in the transaction context (see similarObjectFinder).</li><li>If a similar object is found, access that object, and merge it with the input object (see objectMerger). This may affect the relations of the objects as well.</li><li>For all relations of the merged object, check whether it duplicates a relation already in MMBase. In that case, drop the relation from the transaction context. (Note: relations are considered to be duplicates if both are at least of the same type and reference the same (candidate or existing) MMBase objects, see ObjectMerger).</li><li>For all relations that are dropped, check whether this causes an input object to become unreferenced. In that case drop the input object from the transaction context if required by the user.</li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N100AA" />5.2. objectFinder</h3></div></div></div><p>A class that implements the SimilarObjectFinder interface (see below), this provides methods to search both the persistent cloud and the transaction for similar objects.</p><p>objectFinder parameters - parameters to be passed to the SimilarObjectFinder instance (support for parameterized implementations of similarObjectFinder).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N100B1" />5.3. objectMerger</h3></div></div></div><p>A class that implements the ObjectMerger interface (see below), this provides methods to merge two objects. Also it determines which relations of the merged objects are retained and which are dropped.</p><p>objectMerger parameters - parameters to be passed to the objectMerger instance (support for parameterized implementations of ObjectMerger).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N100B8" />5.4. new parameter for createObject: disposeWhenNotReferenced</h3></div></div></div><p>This sets whether a new object is to be dropped when it becomes unreferenced.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N100BD" />5.5. new parameter for transactions: reportFile</h3></div></div></div><p>Specifies a file to use to report transactions that failed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N100C2" />5.6. SimilarObjectFinder interface</h3></div></div></div><p>methods:</p><div class="itemizedlist"><ul type="disc"><li><pre class="programlisting">void init(java.util.HashMap params)</pre><p>Initialize this instance.</p></li><li><pre class="programlisting">java.util.List findSimilarObject(Transaction transaction, TmpObject tmpObj)</pre><p>Searches for similar object.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N100D4" />5.7. ObjectMerger interface</h3></div></div></div><p>methods:</p><div class="itemizedlist"><ul type="disc"><li><pre class="programlisting">boolean areDuplicates(TmpObject relation1, TmpObject relation2)</pre><p>Tests if two relations should be considered duplicates, indicating that one of them must be disposed of.</p></li><li><pre class="programlisting">void init(java.util.HashMap params)</pre><p>Initialize this instance.</p></li><li><pre class="programlisting">boolean isAllowedToAdd(TmpObject tmpObj)</pre><p>Tests if this object should be added to the persistent cloud when not present already.</p></li><li><pre class="programlisting">void mergeField(TmpObject tmpObj1, TmpObject tmpObj2, java.lang.String name)</pre><p>Merges a field.</p></li><li><pre class="programlisting">void mergeRelations(TmpObject tmpObj1, TmpObject tmpObj2, java.util.List relations1, java.util.List relations2)</pre><p>Merges relations.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N100F8" />6. TransactionHandler enhancements (performance and usability)</h2></div></div></div><p>Further enhancements that will make TCP functionality easier to use than it is now (due to its SCAN- heritage) </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N100FD" />6.1. Performance</h3></div></div></div><p>The current TransactionHandler uses a DOM-parser to parse the transactions from XML. TCP2.0 will replace this with a SAX-parser to improve performance and to reduce memory-usage, especially when importing large files (e.g. tens of MB).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N10102" />6.2. Usability</h3></div></div></div><p>The only way to use the current TransactionHandler is by including the transaction code in a SCAN- page. TCP2.0 will extend this with two mechanisms that enable the TransactionHandler to be accessed more directly.</p><div class="itemizedlist"><ul type="disc"><li>XML-files: A method will be provided that reads and executes transactions directly from a valid XML-file.</li><li>Programatically: TCP2.0 will be implemented in a number of classes/methods that mirror the syntax used in XML. These provide a new interface to TCP, giving direct access to its functionality without the need to translate these to XML first.</li></ul></div><p>This example performs the same actions as the first XML-example above:</p><pre class="programlisting">
transaction = Transaction.createTransaction(uti, null, false, 60);
TmpObject m1 = transaction.createObject("m1", "movie", false);
m1.setField("title", "Psycho"); m1.setField("year", "1960");
TmpObject p1 = transaction.createObject("p1", "person", false);
p1.setField("firstname", "Alfred"); p1.setField("lastname","Hitchcock");
transaction.createRelation(null, "director", "m1", "m2");
transaction.commit();
			</pre><p>Without going into details of the interfaces, it is easily seen that it matches the XML- syntax very closely. In this way TCP2.0 provides a very easy to use interface for transactions.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N10113" />7. TCP 2.0 Syntax</h2></div></div></div><p>The complete syntax for the XML-compliant TCP2.0 transaction language is presented here. See also the Transactions.dtd. TCP2.0 is an extended version of the TCP. See TCP project for details.</p><p>The TCP 2.0 language is quite hierarchical. There is one 'Transactions context' within which can be more 'Transaction contexts', within which can be more 'Object contexts' or 'Object merge contexts'. Within an 'Object context' more fields can be defined. Within an 'Object merge context' more parameters can be defined.</p><p>(The names 'Transactions context' and 'Transaction contexts' might lead to some confusion. We are tied to those names because TCP 2.0 has to be backwards compatible with TCP.)</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N1011C" />7.1. Transactions context</h3></div></div></div><p>The TCP2.0 code might be embedded in some other code (SCAN.... or some other language). So first tag is to indicate that it is TCP2.0: the transactions tag.</p><pre class="programlisting">
&lt;transactions [ exceptionPage="ex-page-def" ] [ key = "password" ] [ reportFile="report.txt" ]  /&gt;
			</pre><p>Note, all symbols are part of the definition except "[" and "]" which denote optional elements.</p><p>The parameter exceptionPage specifies a (s)html page that is shown whenever an error occurs handling the transactions. This can either be a syntax error or it can be an error resulting from an erroneous operation. The key parameter is used to access servers that require a password for transactions. This facility gives extra security.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N10128" />7.2. Transaction contexts</h3></div></div></div><p>Within the 'Transactions context' one can specify zero or more 'Transaction contexts'. There are two 'Transaction contexts' in which no objects can be manipulated. These contexts only affect the transaction itself.</p><pre class="programlisting">
&lt;commit id="id" /&gt;
&lt;delete id="id" /&gt;
			</pre><p>For object manipulation there are two other 'Transaction contexts'.</p><pre class="programlisting">
&lt;open id="id" [ commit="true"(default) / "false" ]  /&gt;
			</pre><p>Within these two transaction context types, objects can be manipulated (TCP) and merged (TCP 2.0). For details see the next sections.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N10137" />7.3. Object contexts</h3></div></div></div><p>Within a 'Transaction context' one can specify zero or more 'Object contexts'. Although a relation might logically differ from an object, for MMBase a relation is just another object.</p><p>There are six different 'Object context' types. Two of them only affect the object as a whole (no fields can be manipulated).</p><pre class="programlisting">
&lt;deleteObject id="id" /&gt;
&lt;markObjectDelete mmbaseId="mmbaseId" [ deleteRelations="true" / "false"(default) ] /&gt;
			</pre><p>For object manipulation (in fact: manipulation of the fields within the object) there are four other object context types.</p><pre class="programlisting">
&lt;accessObject mmbaseId="mmbaseId" [ id ="id" ] /&gt;
&lt;createObject type="MMbase-type" [ id ="id" ]  /&gt;
&lt;openObject id ="id" /&gt;
&lt;createRelation type="MMbase-type" source="id" destination="id" [ id ="id" ] /&gt;
			</pre><p>Within these four object context types, fields can be set for the object. This has the following syntax.</p><pre class="programlisting">
&lt;setField name="name-of-field" [ url ="url" ] &gt; field-value &lt;/setField&gt;
			</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="N1014B" />7.4. Object Merge contexts</h3></div></div></div><p>Within a 'Transaction context' one can specify zero or more 'Object Merge contexts'. In fact this is just another 'Object context'. There is only 1 type for 'Object Merge contexts'.</p><pre class="programlisting">
&lt;mergeObject type="MMbase-type" /&gt;
			</pre><p>Within an Object Merge context you have to specify one ObjectFinder and one ObjectMerger (in this exact order).</p><pre class="programlisting">
&lt;objectFinder class="ObjectFinder class" /&gt;
&lt;objectMerger class="ObjectMerger class" /&gt;
			</pre><p>Within both ObjectFinder and ObjectMerger parameters can be specified:</p><pre class="programlisting">
&lt;param name="name-of-field" value="value-of-field" /&gt;
			</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N1015D" />8. TCP 2.0 dtd</h2></div></div></div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- dec. 1st. 2001 --&gt;

&lt;!ELEMENT transactions (create | open | commit | delete)* &gt;
&lt;!ATTLIST transactions exceptionPage CDATA #IMPLIED&gt;
&lt;!ATTLIST transactions reportFile CDATA #IMPLIED&gt; &lt;!-- TCP2.0 --&gt;
&lt;!ATTLIST transactions key CDATA #IMPLIED&gt;

&lt;!ELEMENT create ((createObject | createRelation | openObject | accessObject | deleteObject | markObjectDelete)*, mergeObject*, mergeObjects*) &gt; &lt;!-- TCP2.0 added mergeObjects* --&gt;
&lt;!ATTLIST create id CDATA #IMPLIED&gt;
&lt;!ATTLIST create commit (true | false) "true"&gt;
&lt;!ATTLIST create timeOut CDATA "60"&gt;

&lt;!ELEMENT open ((createObject | createRelation | openObject | accessObject | deleteObject | markObjectDelete)*, mergeObject*, mergeObjects*) &gt; &lt;!-- TCP2.0 added mergeObjects* --&gt;
&lt;!ATTLIST open id CDATA #REQUIRED&gt;
&lt;!ATTLIST open commit (true | false) "true"&gt;

&lt;!ELEMENT commit EMPTY &gt;
&lt;!ATTLIST commit id CDATA #REQUIRED&gt;

&lt;!ELEMENT delete EMPTY &gt;
&lt;!ATTLIST delete id CDATA #REQUIRED&gt;

&lt;!-- OBJECTS --&gt;
&lt;!ELEMENT createObject (setField*)&gt;
&lt;!ATTLIST createObject id CDATA #IMPLIED&gt;
&lt;!ATTLIST createObject type CDATA #REQUIRED&gt;
&lt;!ATTLIST createObject disposeWhenNotReferenced (true | false) "false"&gt; &lt;!-- TCP2.0 --&gt;

&lt;!ELEMENT createRelation (setField*)&gt;
&lt;!ATTLIST createRelation id CDATA #IMPLIED&gt;
&lt;!ATTLIST createRelation type CDATA #REQUIRED&gt;
&lt;!ATTLIST createRelation source CDATA #REQUIRED&gt;
&lt;!ATTLIST createRelation destination CDATA #REQUIRED&gt;

&lt;!ELEMENT openObject (setField*)&gt;
&lt;!ATTLIST openObject id CDATA #REQUIRED&gt;

&lt;!ELEMENT deleteObject EMPTY &gt;
&lt;!ATTLIST deleteObject id CDATA #REQUIRED&gt;

&lt;!ELEMENT accessObject (setField*)&gt;
&lt;!ATTLIST accessObject mmbaseId CDATA #REQUIRED&gt;
&lt;!ATTLIST accessObject id CDATA  #IMPLIED&gt;

&lt;!ELEMENT markObjectDelete EMPTY &gt;
&lt;!ATTLIST markObjectDelete mmbaseId CDATA #REQUIRED&gt;
&lt;!ATTLIST markObjectDelete deleteRelations (true | false) "false"&gt;

&lt;!ELEMENT mergeObject (objectMerger) &gt; &lt;!-- TCP2.0 --&gt;
&lt;!ATTLIST mergeObject from CDATA #REQUIRED&gt;
&lt;!ATTLIST mergeObject to CDATA #REQUIRED&gt;

&lt;!ELEMENT mergeObjects (objectMatcher, objectMerger) &gt; &lt;!-- TCP2.0 --&gt;
&lt;!ATTLIST mergeObjects type CDATA #REQUIRED &gt; &lt;!-- TCP2.0 --&gt;

&lt;!ELEMENT objectMatcher (param*) &gt; &lt;!-- TCP2.0 --&gt;
&lt;!ATTLIST objectMatcher class CDATA "org.mmbase.module.tcp.match.NodeMatcher" &gt; &lt;!-- TCP2.0 --&gt;

&lt;!ELEMENT objectMerger (param*) &gt; &lt;!-- TCP2.0 --&gt;
&lt;!ATTLIST objectMerger class CDATA "org.mmbase.module.tcp" &gt; &lt;!-- TCP2.0 --&gt;

&lt;!-- FIELDS --&gt;
&lt;!ELEMENT setField (#PCDATA) &gt;
&lt;!ATTLIST setField name CDATA #REQUIRED&gt;
&lt;!ATTLIST setField url CDATA #IMPLIED&gt;

&lt;!-- PARAMETERS --&gt; &lt;!-- TCP2.0 --&gt;
&lt;!ELEMENT param EMPTY&gt; &lt;!-- TCP2.0 --&gt;
&lt;!ATTLIST param name CDATA #REQUIRED&gt; &lt;!-- TCP2.0 --&gt;
&lt;!ATTLIST param value CDATA #REQUIRED&gt; &lt;!-- TCP2.0 --&gt;
	</pre></div></div><hr xmlns="" /><p xmlns="">
      This is part of the <a href="http://www.mmbase.org">MMBase</a> documentation.
    </p><p xmlns="">
      For questions and remarks about this documentation mail to: 
      <a href="/cdn-cgi/l/email-protection#d3b7bcb0a6beb6bda7b2a7babcbd93bebeb1b2a0b6fdbca1b4"><span class="__cf_email__" data-cfemail="5e3a313d2b333b302a3f2a3731301e33333c3f2d3b70312c39">[email&#160;protected]</span></a></p><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body></html>