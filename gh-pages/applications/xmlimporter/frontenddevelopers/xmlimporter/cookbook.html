<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Merging Objects Cookbook</title><link href="../../../../style/documentation.css" rel="stylesheet" type="text/css" /><meta content="DocBook XSL Stylesheets V1.72.0" name="generator" /><link xmlns="" type="image/x-icon" href="../../../../style/favicon.ico" rel="icon" /><link xmlns="" type="image/x-icon" href="../../../../style/favicon.ico" rel="shortcut icon" /><meta xmlns="" content="text/html; charset=utf-8" http-equiv="content-type" /></head><body><div xmlns="" class="navigation"><img alt="mmbase logo" src="../../../../style/logo.png" /><h2>Merging Objects Cookbook</h2><p><a href="cookbook.html#N10021">Introduction</a></p><p><a href="cookbook.html#N10033">SimilarObjectFinder</a></p><p><a href="cookbook.html#N1006E">ObjectMerger</a></p><p><a href="cookbook.html#N1009B">Tips</a></p><p><a href="cookbook.html#N100BA">Performance issues</a></p><p><a href="cookbook.html#N100D1">Documentation</a></p><hr /><p><a href="http://www.mmbase.org">MMBase</a></p><p><a href="../../../../index.html">home</a></p></div><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="N10001" />Merging Objects Cookbook</h1></div><div><div class="authorgroup"><strong class="authorgroup">Author: </strong><span class="author"><span class="firstname">Rob</span> <span class="surname">van Maris</span></span><br /><strong class="authorgroup">Date: </strong>2004-11-04</div></div><div><div class="legalnotice"><a id="N10018" /><p>This software is OSI Certified Open Source Software. OSI Certified is a certification mark of the Open Source Initiative.</p><p>The license (Mozilla version 1.0) can be read at the MMBase site. See <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mmbase.org/license" target="_top">http://www.mmbase.org/license</a></p></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="cookbook.html#N10021">1. Introduction</a></span></dt><dt><span class="section"><a href="cookbook.html#N10033">2. SimilarObjectFinder</a></span></dt><dt><span class="section"><a href="cookbook.html#N1006E">3. ObjectMerger</a></span></dt><dt><span class="section"><a href="cookbook.html#N1009B">4. Tips</a></span></dt><dt><span class="section"><a href="cookbook.html#N100BA">5. Performance issues</a></span></dt><dt><span class="section"><a href="cookbook.html#N100D1">6. Documentation</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N10021" />1. Introduction</h2></div></div></div><p>The most important new concept introduced by XML Importer is merging objects.
    The XML Importer code will handle most of the details for you, and in order to put this to work, all you will have to do is provide implementations for these interfaces:</p><div class="itemizedlist"><ul type="disc"><li><code class="classname">SimilarObjectFinder</code></li><li><code class="classname">ObjectMerger</code></li></ul></div><p>The XML Importer provides basic implementations for both of these, but some additional work will be necessary to meet your needs.</p><p>In this document we'll have a look at some of the issues involved, and give some guidelines.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N10033" />2. SimilarObjectFinder</h2></div></div></div><p>When we have populated a transaction with (access and input) objects, we can merge all objects of a given type. In order to do so, the XML Importer performs these actions:</p><div class="orderedlist"><ol type="1"><li>Walk through the list of objects in the transaction - in the order they were added to the transaction - of the given type.</li><li>For each such object, look for a similar object.</li><li>If a similar object is found, merge both objects to a single object.</li><li>If more than one similar object is found, the transaction cannot proceed, unless the user can choose the object to merge with.</li></ol></div><p>The SimilarObjectFinder is needed to implement step 2. One fairly general way to do this is implemented by BasicFinder, which makes a distinction between <span class="emphasis"><em>exact matches</em></span> (i.e. indistinguishable) and <span class="emphasis"><em>non-exact matches</em></span> (e.g. different, but considered to be the same, based on some specified criteria - i.e. fuzzy comparison):</p><div class="orderedlist"><ol type="1"><li>Walk through the list of objects in the transaction, that were added before this one, compare these with this object, and keep the results as a list of exact matches and a list of non-exact matches.</li><li>Look for exact matches in the persistent cloud</li><li>If exact matches were found in step 1 or 2, these are returned as the result of the search.</li><li>Otherwise, look for objects in the persistent cloud that are close enough to warrant further inspection, and compare these with this object.</li><li>If non-exact matches were found in step 1 or 4, these are returned as the result of the search.</li></ol></div><p>This strategy has these characteristics:</p><div class="itemizedlist"><ul type="disc"><li>If the transaction introduces a number of similar objects, these are merged one by one, in the order they were added to the transaction.</li><li>If an exact match is found, the non-exact matches are ignored.</li><li>Searching the persistent cloud for non-exact matches occurs only if no exact match is found (performance optimimalization).</li><li>Searching the persistent cloud for non-exact matches is performed in two parts: selecting objects that are close enough, followed by comparing these objects with this object (performance optimalization, since this reduces the number of objects to be compared).</li></ul></div><p>For examples of implementation based on BasicFinder, see MoviesFinder and PersonsFinder in the XML Importer examples code.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N1006E" />3. ObjectMerger</h2></div></div></div><p>The ObjectMerger is needed to implement merging two objects to a single object. In order to do so, the XML Importer performs these actions:</p><div class="orderedlist"><ol type="1"><li>If one of the objects represents a persistent object, this object is made the <span class="emphasis"><em>merge target</em></span>, e.g. the object that will hold the merge result.</li><li>The fields of both objects are merged - the resulting fields are set on the merge target.</li><li>The relations of both objects are merged - the resulting relations are set to the merge target.</li><li>If step 3 results in duplicate relations, the duplicating relations are deleted.</li><li>Of the two objects, only the merge target is retained - the object that is not the merge target is deleted.</li><li>If there was no similar object to merge with, this object will only be kept in the transaction if the ObjectMerger specifies so (see method <code class="methodname">isAllowedToAdd()</code> in ObjectMerger).</li></ol></div><p>A fairly general implementation is provided by BasicMerger, which has these characteristics:</p><div class="itemizedlist"><ul type="disc"><li>The fields of the merge target are unaffected (e.g. the merge result has the same fields of the merge target).</li><li>The relations of both objects are moved to the merge result.</li><li>Relations are considered duplicates when of same type and with same source and destination (e.g. in this case the duplicating relations are deleted).</li><li>Objects for which no similar object is found, are kept in the transaction.</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N1009B" />4. Tips</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li>As a general rule, keep the transactions small.</li><li>If a number of transactions involve merging with the same objects over and over, it is worthwhile to combine these into a single transaction.</li><li>Within a transaction, the same object in the persistent cloud can be accessed repeatedly (e.g. &lt;accessObject mmbaseId="12345" id="id12345"&gt;), provided the same id is used each time. This proves handy when the XML file containing the TCP code is generated by a stylesheet transformation, where it can be hard to establish if an object had been accessed within the same transaction already. Just use the mmbaseId to create a unique id, so the same id will be used when accessing the same object again.</li><li>When it comes to performance and resources, merging objects can be expensive, therefore try to <span class="emphasis"><em>use the merging mechanism only when really needed</em></span>. As an alternative, in many cases objects can be be accessed directly using their mmbase id.</li><li>If you want to see wich objects are merged, set logging priority for the class <code class="classname">Transaction</code> to "debug", and look at the log output of the Transaction method <code class="methodname">commit()</code>.</li><li>Set the timeOut to a value sufficient for the transaction to be completed under normal circumstances. Keep in mind that transactions take longer to complete in interactive mode.</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N100BA" />5. Performance issues</h2></div></div></div><p>Merging objects can put a heavy stress on the MMBase server and database, so it is important to be aware of the following perfomance issues.</p><div class="itemizedlist"><ul type="disc"><li>When two objects are merged, all their relations are added to the transaction in order to be processed. Try to <span class="emphasis"><em>avoid merging objects that have a large number of relations</em></span>.</li><li><p>When using SimilarObjectFinder to merge objects, based on a fuzzy match criterium, the search for non-exact matches in the persistent cloud occurs in two stages:
        <div class="orderedlist"><ol type="1"><li>Query the database for objects that are close enough and access these objects in the transaction.</li><li>Compare these with the original object.</li></ol></div>
      </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="N100D1" />6. Documentation</h2></div></div></div><p>For a full understanding of the XML Importer, it is recommended to read the following documents, available on the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mmbase.org" target="_top">MMBase website</a></p><div class="orderedlist"><ol type="1"><li>TCP 1.0 documentation (see Temporary Cloud Project).</li><li>XML Importer overview (see XML Importer Project).</li><li>The javadoc documentation of the <code class="classname">org.mmbase.applications.xmlimporter</code> package.</li></ol></div></div></div><hr xmlns="" /><p xmlns="">
      This is part of the <a href="http://www.mmbase.org">MMBase</a> documentation.
    </p><p xmlns="">
      For questions and remarks about this documentation mail to: 
      <a href="/cdn-cgi/l/email-protection#d8bcb7bbadb5bdb6acb9acb1b7b698b5b5bab9abbdf6b7aabf"><span class="__cf_email__" data-cfemail="33575c50465e565d4752475a5c5d735e5e515240561d5c4154">[email&#160;protected]</span></a></p><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body></html>